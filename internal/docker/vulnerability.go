package docker

import (
	"encoding/json"
	"fmt"
	"os/exec"

	"github.com/NucleoFusion/cruise/internal/enums"
	"github.com/NucleoFusion/cruise/internal/utils"
)

type Vulnerability struct {
	VulnID     string
	Pkg        string // PkgName
	Severity   enums.Severity
	Title      string
	Published  string
	PrimaryURL string
}

func VulnHeaders(totalWidth int) string {
	w := totalWidth / 15
	return fmt.Sprintf(
		"%-*s %-*s %-*s %-*s %-*s %-*s",
		2*w, "ID",
		2*w, "Pkg",
		totalWidth-15*w, "Severity",
		5*w, "Title",
		2*w, "Date",
		3*w, "URL")
}

func (s Vulnerability) Format(totalWidth int) string {
	w := totalWidth / 15
	return fmt.Sprintf(
		"%-*s %-*s %-*s %-*s %-*s %-*s",
		2*w, utils.Shorten(s.VulnID, 2*w),
		2*w, utils.Shorten(s.Pkg, 2*w),
		totalWidth-15*w, SeverityText(s.Severity),
		5*w, utils.Shorten(s.Title, 5*w),
		2*w, utils.Shorten(s.Published, 2*w),
		3*w, utils.Shorten(s.PrimaryURL, 3*w))
}

func SeverityText(sev enums.Severity) string {
	switch sev {
	case enums.Critical:
		return "CRITICAL"
	case enums.High:
		return "HIGH"
	case enums.Medium:
		return "MEDIUM"
	case enums.Low:
		return "LOW"
	default:
		return "UKNOWN"
	}
}

func ScannerAvailable(scanner string) bool {
	_, err := exec.Command("bash", "-c", scanner+" --version").CombinedOutput() // TODO: Config file based checker
	return err == nil
}

func TrivyScanImage(name string) ([]Vulnerability, error) {
	report := struct {
		Results []struct {
			Vulns []struct {
				VulnerabilityID  string
				PkgName          string
				InstalledVersion string
				Title            string
				Severity         string
				Description      string
				PrimaryURL       string
				PublishedDate    string
			} `json:"Vulnerabilities"`
		} `json:"Results"`
	}{}

	out, err := exec.Command("bash", "-c", fmt.Sprintf("trivy image %s --format json", name)).Output() // TODO: Use custom shell (as provided by config)
	if err != nil {
		return nil, err
	}

	err = json.Unmarshal(out, &report)
	if err != nil {
		return nil, err
	}

	arr := make([]Vulnerability, 0)
	for _, res := range report.Results {
		for _, v := range res.Vulns {
			vuln := Vulnerability{
				VulnID:     v.VulnerabilityID,
				Title:      v.Title,
				Severity:   GetSeverity("trivy", v.Severity),
				Pkg:        v.PkgName + " " + v.InstalledVersion,
				Published:  v.PublishedDate,
				PrimaryURL: v.PrimaryURL,
			}
			arr = append(arr, vuln)
		}
	}

	return arr, nil
}

func GrypeScanImage(name string) ([]Vulnerability, error) {
	report := struct {
		Matches []struct {
			Vulnerability struct {
				ID          string   `json:"id"`
				Description string   `json:"description"`
				Severity    string   `json:"severity"`
				URLs        []string `json:"urls"`
			} `json:"vulnerability"`
			Artifact struct {
				Name    string `json:"name"`
				Version string `json:"version"`
			} `json:"artifact"`
		} `json:"matches"`
	}{}

	out, err := exec.Command("bash", "-c", fmt.Sprintf("grype %s -o json", name)).Output() // TODO: Use custom shell (as provided by config)
	if err != nil {
		return nil, err
	}

	err = json.Unmarshal(out, &report)
	if err != nil {
		return nil, err
	}

	arr := make([]Vulnerability, 0)
	for _, v := range report.Matches {
		url := "NA"
		if len(v.Vulnerability.URLs) > 0 {
			url = v.Vulnerability.URLs[0]
		}
		vuln := Vulnerability{
			VulnID:     v.Vulnerability.ID,
			Title:      v.Vulnerability.Description,
			Severity:   GetSeverity("grype", v.Vulnerability.Severity),
			Pkg:        v.Artifact.Name + " " + v.Artifact.Version,
			Published:  "NA",
			PrimaryURL: url,
		}
		arr = append(arr, vuln)
	}

	return arr, nil
}

func GetSeverity(scanner, severity string) enums.Severity {
	switch severity {
	case "CRITICAL":
		return enums.Critical
	case "HIGH":
		return enums.High
	case "MEDIUM":
		return enums.Medium
	case "LOW":
		return enums.Low
	default:
		return enums.Unknown
	}
}
